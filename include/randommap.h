/*
 * This function is to gennerate a random map by coherent noise module.
 *
 * To directly use the 2D coherent noise map will not give a sensable map, so
 *  we use the sum of noise maps in different frequencies. The low-freq map
 *  provides the macro terrain with a large coefficient, and the high-freq map
 *  provides the micro roughness with a small coeffcient.
 * The octave controls how many components contributes to the final map, and 
 *  the highest freq is 2 to the octave-th power times of the lowest freq. With
 *  the freq's increasing, the coefficient decreases exponentially.
 *
*/
#ifndef NOISE_H
#define NOISE_H

#include <vector>
#include <functional>
#include <algorithm>
#include <random>

namespace noise{
  double cubic_func(double x, const double param0, const double param1, const double param2, const double param3);
  // input:
  //   x: independent varibale
  //   param0 - param3: coefficients associated with x to the i th
  // return the value of the cubic polynomial function
  
  std::vector<double> discrete_random_series(unsigned int size);
  // input:
  //   size: the number of regions for following interpolation
  //   
  // return a series of random numbers in length of size+1

  std::vector<std::function<double(double)>> cubic_spline_functions(const std::vector<double>& rdlist, const double step=1.0);
  // input:
  //   rdlist: random number series
  //   step: defined interval between two numbers in the random number series
  // return a vector of function object generated by spline interpolation algorithm
  
  std::vector<double> coherent_series(std::vector<std::function<double(double)>> splines_function, unsigned int samples=20, const double step=1.0);
  // input:
  //   splines_function: a vector of spline function object
  //   samples: number of points between two fixed random numbers
  //   step: defined interval between two numbers in the random number series
  // return a coherent noise series in length of size*samples+1

  std::vector<double> coherent_series(unsigned int size, unsigned int samples=20);
  // combine the steps above
  // return a coherent noise series in length of size*samples+1
  
  std::vector<std::vector<double>> coherent_map(unsigned int size1, unsigned int size2, unsigned int sample1=20, unsigned int sample2=20);
  // return a 2D transposed coherent noise map in size of (size2*samples2+1,size1*samples1+1)
};

#endif
